Suppose you had an array 𝐴
of 𝑛
elements, each of which is 0
or 1
.

Let us define a function 𝑓(𝑘,𝐴)
which returns another array 𝐵
, the result of sorting the first 𝑘
elements of 𝐴
in non-decreasing order. For example, 𝑓(4,[0,1,1,0,0,1,0])=[0,0,1,1,0,1,0]
. Note that the first 4
elements were sorted.

Now consider the arrays 𝐵1,𝐵2,…,𝐵𝑛
generated by 𝑓(1,𝐴),𝑓(2,𝐴),…,𝑓(𝑛,𝐴)
. Let 𝐶
be the array obtained by taking the element-wise sum of 𝐵1,𝐵2,…,𝐵𝑛
.

For example, let 𝐴=[0,1,0,1]
. Then we have 𝐵1=[0,1,0,1]
, 𝐵2=[0,1,0,1]
, 𝐵3=[0,0,1,1]
, 𝐵4=[0,0,1,1]
. Then 𝐶=𝐵1+𝐵2+𝐵3+𝐵4=[0,1,0,1]+[0,1,0,1]+[0,0,1,1]+[0,0,1,1]=[0,2,2,4]
.

You are given 𝐶
. Determine a binary array 𝐴
that would give 𝐶
when processed as above. It is guaranteed that an array 𝐴
exists for given 𝐶
in the input.

### ideas

1. c[0] = sum(b[i][0]), c[i] = sum(b[?][i])
2. 有一个观察, b[i][j] (第j位)如果c[j] != 0, 那么前面c[j]个b[?][j] = 1
3. 因为通过排序后，c[j]这里越来越可能出现0，且一旦出现0， 就不会变成1
4. 但是这个结论只有在前i位被排序后的结果
5. 假设到到i为止，有x个1，如果当前a[i] = 1, 那么就会出现x+1个1，反过来也是成立的
6. 但如何判断多了一个1呢？c[i] = 1 (x > 0)代表当前位等于0，因为排序后移动到这里来了，否则这位就是1