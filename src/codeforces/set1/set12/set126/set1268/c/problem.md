You are given a permutation ğ‘1,ğ‘2,â€¦,ğ‘ğ‘›
.

In one move you can swap two adjacent values.

You want to perform a minimum number of moves, such that in the end there will exist a subsegment 1,2,â€¦,ğ‘˜
, in other words in the end there should be an integer ğ‘–
, 1â‰¤ğ‘–â‰¤ğ‘›âˆ’ğ‘˜+1
 such that ğ‘ğ‘–=1,ğ‘ğ‘–+1=2,â€¦,ğ‘ğ‘–+ğ‘˜âˆ’1=ğ‘˜
.

Let ğ‘“(ğ‘˜)
 be the minimum number of moves that you need to make a subsegment with values 1,2,â€¦,ğ‘˜
 appear in the permutation.

You need to find ğ‘“(1),ğ‘“(2),â€¦,ğ‘“(ğ‘›)
.

### ideas
1. range update with lazy segment
2. å‡è®¾0çš„å¼€å§‹ä½ç½®æ˜¯iï¼Œç°åœ¨è¦æŠŠnæ”¾è¿›å»ï¼Œ å®ƒçš„costæ˜¯å¤šå°‘å‘¢ï¼Ÿ
3. å¦‚æœnåœ¨0...n-1çš„å¤–éƒ¨ï¼Œè¿™ä¸ªcoståº”è¯¥ = abs(pos[n] - (i + n)) ?
4. å¦‚æœpos[n]åœ¨0...n-1çš„å†…éƒ¨ï¼Œ æ˜¯ä¸æ˜¯å°±æ˜¯0ï¼Ÿ
5. å› ä¸ºå†ç§»åŠ¨0.ã€‚ã€‚n-1çš„æ—¶å€™ï¼Œè‡ªç„¶çš„å°±å¯ä»¥æŠŠnç§»åŠ¨åˆ°éœ€è¦çš„ä½ç½®å»ï¼Ÿ
6. ä¸å¤§å¯¹ã€‚ è€ƒè™‘åºåˆ— 3, 2, 1, 0
7. dp[0] = 3, dp[1] = 2, dp[2] = 1, dp[3] = 0, f(0) = 0
8. dp[0] = 4, dp[1] = 2, dp[2] = 1, dp[3] = inf, f(1) = 1
9. dp[0] = 4, dp[1] = 3, dp[2] = inf, dp[3] = inf, f(2) = 3
10. dp[0] = 6, dp[1] = inf, ... f(3) = 6
11. ç¬¬ä¸€ä¸ªç‚¹å°±æ˜¯ï¼ŒæŠŠæ–°çš„nåŠ å…¥åˆ°é‡Œé¢åï¼Œ æ€ä¹ˆè®¡ç®—æ–°çš„costï¼Ÿ
12. è¿˜æœ‰å°±æ˜¯ï¼Œ æ–°çš„dpï¼Œè²Œä¼¼ä¸èƒ½ä»åŸæœ‰çš„dpç›´æ¥å¾—åˆ°
13. ç‰¹åˆ«çš„åœ¨å¤„ç†3çš„æ—¶å€™ï¼Œå¹¶ä¸æ˜¯æŠŠdp[0] + 3ä»ä½ç½®0ç§»åŠ¨åˆ°ä½ç½®3çš„cost
14. å¥½åƒå’Œinversion count æœ‰å…³ç³»
15. åªè€ƒè™‘0...nï¼Œè‡³å°‘è¦ä½¿ç”¨inversion count çš„æ“ä½œæ¬¡æ•°ï¼Œæ¥ä½¿çš„å®ƒä»¬æ’å¥½åº
16. å…ˆæŠŠå®ƒä»¬èšåˆåœ¨ä¸€èµ·ï¼Œå æ®ä½ç½®i...i+n-1, ç„¶åæ’åº
17. æ¯”å¦‚ 1,3,2,0,4 è¦è®¡ç®—f(2), å…ˆå¾—åˆ°120ï¼Œå‡è®¾èµ·ç‚¹åœ¨1ï¼Œ é‚£ä¹ˆç§»åŠ¨è·ç¦» = 1 + 0 + 0 = 1
18. è¿™ä¸ªè²Œä¼¼ä¸èƒ½dpï¼Œåº”è¯¥æ˜¯è´ªå¿ƒã€‚å°±æ˜¯æŠŠiç§»åŠ¨åˆ°é è¿‘ä¸­é—´çš„ä½ç½®
19. å‡è®¾è¿™ä¸ªåŒºé—´æ˜¯ l...r, é‚£ä¹ˆç§»åŠ¨çš„æœ€çŸ­è·ç¦» = ï¼Ÿ
20. dp[i] = è¡¨ç¤ºæœ€å·¦è¾¹çš„ä½ç½®åœ¨içš„æ—¶å€™ï¼ŒæŠŠå‰n-1ç§»åŠ¨åˆ°ä¸€èµ·æ—¶çš„æœ€çŸ­ç§»åŠ¨è·ç¦»ï¼ˆä¸è€ƒè™‘inversion count)
21. æ¯”å¦‚æŠŠ1ï¼Œ2ï¼Œ0ç§»åŠ¨åˆ°ä½ç½®0å¼€å§‹ï¼Œéœ€è¦èŠ±è´¹2
22. ç°åœ¨è€ƒè™‘3ï¼ŒèŠ±è´¹å±…ç„¶æ˜¯0.ã€‚ã€‚
23. i...i+n-1, è¿™ä¸ªåŒºé—´çš„cost = åœ¨è¿™ä¸ªåŒºé—´å¤–è¾¹çš„, ä½†æ˜¯value å´åœ¨è¿™ä¸ªåŒºé—´é‡Œè¾¹çš„ç§»åŠ¨çš„è·ç¦»ä¹‹å’Œ
24. å‡è®¾l...rçš„ç¬¬midä¸ªç‚¹ï¼Œé‚£ä¹ˆåªè¦æŠŠ0...nçš„midå’Œå®ƒå¯¹é½å°±å¯ä»¥äº†
25. å‡è®¾èµ·ç‚¹æ˜¯i, i - pos[0] + i + 1 - pos[1] + ... i + mid - pos[mid] + pos[mid+1] - (i+mid+1) + ... + pos[n] - (i + n)
26. l - pos[0] + pos[n] - r = pos[n] - pos[0] - (r - l) 
27. l + 1 - pos[1] + pos[n-1] - (r - 1) = pos[n-1] - pos[1] - (r - l) + 2
28. ...
29. l + mid - pos[mid] + pos[n - mid] - (r + mid ) = pos[n-mid] - pos[mid] - (r - l) + 2 * mid 
30. æ‰€ä»¥ï¼Œå…¶å®å¯ä»¥å’Œiæ— å…³çš„
31. sum of second half - sum of first half - n / 2 * n + 2 * (0 + ... + mid)
32. å‰nä¸ªçš„ç§»åŠ¨è·ç¦» + inversion count å°±æ˜¯ç­”æ¡ˆ
33. ç§»åŠ¨è·ç¦» = å‰ä¸€åŠçš„ä½ç½®å’Œçš„è´Ÿæ•° + åä¸€åŠçš„ä½ç½®å’Œ 
34. inversion count ä¹Ÿå¾ˆå¥½å¤„ç†
35. å±…ç„¶æå¯¹äº†ï½ï½