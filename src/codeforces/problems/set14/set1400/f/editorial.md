The number of ğ‘¥-prime strings is relatively small, so is their total length (you may bruteforce all of them and check that the total length of ğ‘¥-prime strings never exceeds 5000, we will need that bruteforce in the solution). Now we have the following problem: given a set of strings with total length up to 5000 and a string with length up to 1000, erase the minimum number of characters from that string so no string from the set appears there as a substring.

You may have already encountered the similar problem in some previous contests. The solution to this problem is dynamic programming â€” let ğ‘‘ğ‘[ğ‘¥][ğ‘¦] be the minimum number of characters to erase, if we considered first ğ‘¥ characters, there were no occurrences of strings from the set in the resulting string... and the second state of dynamic programming (ğ‘¦) is a bit more complicated. We want to make sure that no string appears in the result as a substring, so ğ‘¦ should somehow handle that. Let ğ‘¦ be the longest suffix of the current string that coincides with some prefix of a string from the set. If some string from the set is a suffix of ğ‘¦, then the state is clearly bad â€” we have an occurrence of an ğ‘¥-prime string. Otherwise, there is no occurrence ending in the last character, since we considered the longest possible suffix that matches some prefix from the set. The transitions in ğ‘‘ğ‘ are the following â€” we either take the next character and recalculate ğ‘¦, or skip the next character and add 1 to the number of removed characters.

If we maintain and recalculate ğ‘¦ naively, as a string, the solution will be too slow. There are only up to 5000 different values of ğ‘¦, but their total length may be much greater, so we don't even have enough memory to store our dynamic programming values. Let's enumerate all strings that are prefixes of some ğ‘¥-prime string and map each of these strings to some integer, so the second state in dynamic programming can be an integer instead of a string. Then we have to mark the bad integers (which correspond to strings having some ğ‘¥-prime string as a suffix) and calculate the two-dimensional transition matrix ğ‘‡, where ğ‘‡[ğ‘¥][ğ‘] is the integer corresponding to a string that we get, if we append the ğ‘¥-th string with character ğ‘, so the transitions in dynamic programming can be done in ğ‘‚(1). There are many ways to precalculate this matrix and mark all of the bad integers, but the most efficient one is to use Aho-Corasick algorithm (the transition matrix ğ‘‡ is exactly the automaton that the Aho-Corasick algorithm builds). If you are not familiar with it, I recommend you to read about it here: https://cp-algorithms.com/string/aho_corasick.html