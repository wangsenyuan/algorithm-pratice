Let's call the value of all elements in the second half of the array ğ‘¥.

Let ğ‘ ğ‘–=ğ‘ğ‘–+ğ‘ğ‘–+1+â€¦+ğ‘ğ‘–+ğ‘˜âˆ’1 â€” the reported incomes.

Pretend there exists such a ğ‘˜ that ğ‘˜â‰¤ğ‘›2. Consider the following reported incomes: ğ‘ ğ‘– and ğ‘ ğ‘–+ğ‘˜. Notice that if we double ğ‘˜, the ğ‘–-th reported income will be equal to ğ‘ ğ‘–+ğ‘ ğ‘–+ğ‘˜. ğ‘ ğ‘–>0 and ğ‘ ğ‘–+ğ‘˜>0 imply ğ‘ ğ‘–+ğ‘ ğ‘–+ğ‘˜>0. It means that after doubling ğ‘˜, the new value will still be correct  âŸ¹  if some ğ‘˜ exists, there's also ğ‘˜>ğ‘›2.

Now, let's notice that ğ‘ ğ‘–+1=ğ‘ ğ‘–+(ğ‘ğ‘–+ğ‘˜âˆ’ğ‘ğ‘–).

It means we can think of ğ‘ ğ‘– as prefix sums of the following array: ğ‘=[ğ‘ 1, ğ‘ğ‘˜+1âˆ’ğ‘1, ğ‘ğ‘˜+2âˆ’ğ‘2, â€¦, ğ‘ğ‘›âˆ’ğ‘ğ‘›âˆ’ğ‘˜].  As ğ‘˜>ğ‘›2, ğ‘ğ‘˜+ğ‘—=ğ‘¥ holds for ğ‘—â‰¥0, so, actually ğ‘=[ğ‘ 1, ğ‘¥âˆ’ğ‘1, ğ‘¥âˆ’ğ‘2, â€¦, ğ‘¥âˆ’ğ‘ğ‘›âˆ’ğ‘˜].

How is this array changed when we increment ğ‘˜ by 1? ğ‘ğ‘›ğ‘’ğ‘¤=[ğ‘ 1+ğ‘ğ‘˜+1, ğ‘ğ‘˜+2âˆ’ğ‘1, ğ‘ğ‘˜+3âˆ’ğ‘2, â€¦, ğ‘ğ‘›âˆ’ğ‘ğ‘›âˆ’ğ‘˜âˆ’1], which equals [ğ‘ 1+ğ‘¥, ğ‘¥âˆ’ğ‘1, ğ‘¥âˆ’ğ‘2, â€¦, ğ‘¥âˆ’ğ‘ğ‘›âˆ’ğ‘˜âˆ’1].  So, when you increase ğ‘˜ by 1, the first element is changed, and the last element is removed â€” and that's it.

Recall that ğ‘ ğ‘–=ğ‘1+ğ‘2+â€¦+ğ‘ğ‘–. Notice that the minimum reported income (some number from ğ‘ ) doesn't depend on the first element of ğ‘ because it's a term of all sums (ğ‘ 1,ğ‘ 2,â€¦). For example, if ğ‘1 is increased by 1, all ğ‘ ğ‘– are increased by 1 too. So, let's calculate the following array ğ‘š:  ğ‘šğ‘–=ğ‘šğ‘–ğ‘›(ğ‘ 1âˆ’ğ‘1,ğ‘ 2âˆ’ğ‘1,â€¦,ğ‘ ğ‘–âˆ’ğ‘1)=ğ‘šğ‘–ğ‘›(0,ğ‘2, ğ‘2+ğ‘3, â€¦, ğ‘2+â€¦+ğ‘ğ‘–).  This can be done in îˆ»(ğ‘›).

Notice that this array is the same for all ğ‘˜, except its size. So, it's obvious that the minimum reported income for a particular ğ‘˜ is ğ‘1+ğ‘šğ‘›âˆ’ğ‘˜+1=ğ‘1+â€¦+ğ‘ğ‘˜+ğ‘šğ‘›âˆ’ğ‘˜+1. So, we can just check if this number is greater than 0 for some ğ‘˜.

We can calculate prefix sums and ğ‘š in îˆ»(ğ‘›), so the overall complexity is îˆ»(ğ‘›).