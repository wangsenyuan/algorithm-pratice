小 C 是一个算法竞赛爱好者，有一天小 C 遇到了一个非常难的问题：求一个序列的最大子段和。

但是小 C 并不会做这个题，于是小 C 决定把序列随机打乱，然后取序列的最大前缀和作为答案。

小 C 是一个非常有自知之明的人，他知道自己的算法完全不对，所以并不关心正确率，他只关心求出的解的期望值，现在请你帮他解决这个问题，由于答案可能非常复杂，所以你只需要输出答案乘上 
𝑛
!
n! 后对 
998244353
998244353 取模的值，显然这是个整数。

注：最大前缀和的定义：
∀
𝑖
∈
[
1
,
𝑛
]
∀i∈[1,n]，
∑
𝑗
=
1
𝑖
𝑎
𝑗
∑ 
j=1
i
​
 a 
j
​
 的最大值。


 ### ideas
 
 1. 难道就是brute force？
 2. dp[state] 表示state代表的期望值
 3. dp[next] = max(dp[state], sum(next state 代表的数字))
 4. 这个不对， 因为 dp[state]代表的是期望值，和这个sum一致吗？
 5. 如果所有的数字a[i] >= 0, dp[state] = sum(of state)
 6. dp[state] 表示能够用state表示的最长前缀和的期望值
 7. dp[next] = 加入一个新的a[i]，如果a[i] >= 0, dp[next] = dp[state] + a[i]
 8. 否则的话， dp[next] = dp[state]